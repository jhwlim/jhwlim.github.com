---
title: "[자료구조] 시작하기 ② Big-O"
excerpt: ""
categories: data-structure
tags: cs data-structure algorithm big-o
---
> 이 글은 [열혈강의 - 이상진의 자료구조](https://www.youtube.com/playlist?list=PL7mmuO705dG12pP82RPUR3wdD5dbYu9gZ) YouTube 강의를 보면서 개인적으로 공부한 내용을 정리한 글임을 밝힙니다.

## 효율적인 알고리즘이란?
알고리즘이란 어떠한 문제를 해결하기 위한 절차입니다. 문제를 해결하기 위해서는 다양한 방법들이 존재할 수 있고, 그 안에서 자원을 적게 필요로 하는 것이 효율적이고 좋은 알고리즘이라고 할 수 있습니다. 컴퓨터 과학에서 효율적인 알고리즘은 메모리 공간을 적게 필요로 하면서, 수행시간이 빠른 알고리즘입니다.

## 복잡도
효율적인 알고리즘을 선택하기 위해 알고리즘의 성능 분석이 필요합니다. 이때, 알고리즘의 성능을 평가하는 기준이 **복잡도** (Complexity) 입니다. 복잡도는 **공간복잡도** (Space Complexity)와 **시간복잡도** (Time Complexity)로 나뉩니다.

### 공간복잡도
알고리즘이 수행되는데 메모리 공간이 얼마나 필요한지를 평가하는 기준입니다.

### 시간복잡도
알고리즘이 수행되는데 걸리는 시간을 평가하는 기준입니다. 실제 걸리는 시간을 측정해야 하지만 실행환경(CPU 등)에 따라 차이가 있기 때문에, 일반적으로 입력값에 따라 실행되는 명령문의 개수를 계산하여 평가합니다.

## Big-O
Big-O 표기법은 알고리즘의 효율성을 비교할 때 사용되는 표기법입니다. 시간복잡도에서는 입력값 *n* 에 대하여 실행되는 명령어의 개수를 의미합니다.

Big-O 표기법은 입력값 *n* 에 따라 실행시간이 얼마나 증가하는지를 비율로 나타내는 개념이기 때문에, 아래와 같이 수식을 단순화할 수 있습니다.

(1) 가장 큰 영향을 미치는 *n* 에 대한 항만을 표기합니다.

(2) 계수(coefficient)는 생략합니다.

- *O(3N<sup>2</sup>+N)* => *O(N<sup>2</sup>)*
- *O(4)* => *O(1)*

## 성능비교
<center>
O(1) &nbsp;> &nbsp;O(logn)&nbsp; >&nbsp; O(n)&nbsp; >&nbsp; O(n<sup>2</sup>)&nbsp; >&nbsp; O(n<sup>3</sup>)&nbsp; >&nbsp; O(2<sup>n</sup>)&nbsp; >&nbsp; O(n!)
</center>
